@keyframes moveInLeft {
  0% {
    opacity: 0;
    /* Beginning of animation we want the property to be invisible */
    transform: translateX(-10rem);
    /* x axis goes from left to right so a positive number makes it go further right but we want this to come in from left and go right so we put it as a negative number because we want it to start out 100px to the left from its normal starting position */ }
  80% {
    transform: translateX(1rem);
    /* At 80% of animation we want the text to go further right than its normal position by 10px */ }
  100% {
    opacity: 1;
    /* End of animation we want the property to be invisible */
    transform: translate(0);
    /* 0 will end animation at its final ending spot which is equivalent to where it would show on page if there was no animation on page. */ } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    /* Beginning of animation we want the property to be invisible */
    transform: translateX(10rem);
    /* x axis goes from left to right so a positive number makes it go further right from its normal starting position */ }
  80% {
    transform: translateX(-1rem);
    /* At 80% of animation we want the text to go further left than its normal position by 10px */ }
  100% {
    opacity: 1;
    /* End of animation we want the property to be invisible */
    transform: translate(0);
    /* 0 will end animation at its final ending spot which is equivalent to where it would show on page if there was no animation on page. */ } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    /* Beginning of animation we want the property to be invisible */
    transform: translateY(3rem);
    /* y axis goes from top to bottom so a positive number makes it go further down from its normal position. So because we put this further down from its normal position when the animation gets beyond the 0% state and at 100% we have it at transform:translate(0) which is its normal position which is higher so as a result the button will move up because it starts lower than its normal position and moves up to finish at its normal position. */ }
  100% {
    opacity: 1;
    /* End of animation we want the property to be invisible */
    transform: translate(0);
    /* 0 will end animation at its final ending spot which is equivalent to where it would show on page if there was no animation on page. */ } }

*,
*::after,
*::before {
  /*    * - Is the universal selector that selects everything  */
  margin: 0;
  /* Eliminates browser default margins as we want to start clean */
  padding: 0;
  /* Eliminates browser default padding as we want to start clean */
  box-sizing: inherit;
  /* This forces all elements on page to inherit properties from their parent when it comes to box-sizing. */ }

html {
  font-size: 62.5%;
  /* All rem's based off this % here which is based originally off of 10px; Wanted to use everything by 10px. All the rem's originally used to style page used 10px but to make page more responsive and easier to modify we take the rem size we used to model our page after and then we divide that by the normal user font size which is 16px (10 /16 = .625 or 62.5%). Now this will take user font-size and scale it down to 62.5% and then adjust all our font-sizes accordingly throughout the page. */ }

body {
  box-sizing: border-box;
  /* Eliminates margins and padding in width and height of box. When you specify an elements width or height that measurement will include the margin and padding. The border box property adjusts the box accordingly to make the box the total measurements specified. Other properties if set width to 100% for example the border and padding would cause element to protrude further out from it box or container. */ }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  font-size: 1.6rem;
  line-height: 1.7;
  color: #777;
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  /* This fixes any unknown shakiness in animation */
  margin-bottom: 6rem; }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    font-weight: 700;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    /* Can specify each animation property separately or do it on one line like in .heading-primary-sub below */
    animation-duration: 1s;
    animation-timing-function: ease-out;
    padding-left: 3.5rem; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 400;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out;
    /* All animation properties specified in one line instead of listing out each one separately on to its own line like .heading-primary-main above. These properties could be listed out in any order. Order does not matter here. */
    padding-left: 1.75rem; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  display: inline-block;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  -webkit-background-clip: text;
  color: transparent;
  letter-spacing: .2rem;
  transition: all .2s; }
  .heading-secondary:hover {
    transform: skew(15deg, 2deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem; }

.u-margin-bottom-medium {
  margin-bottom: 4rem; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.btn:link, .btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  /* When two values entered the first one is padding for top and bottom and 2nd is for padding left/right */
  display: inline-block;
  /* Need to go to parent div container with class .text-box and place text-align : center to center this */
  border-radius: 10rem;
  transition: all .2s;
  /* must be on initial state which is the .btn:link and the .btn:visited */
  position: relative;
  /* Added this relative positioning so that the .btn::after could be positioned absolute. */
  font-size: 1.6rem; }

.btn:hover {
  transform: translateY(-3px);
  /* Y axis goes from top to bottom so a positive number would move it down. We want to move the button up upon hover so you input a negative #. This will move it based upon its original position */
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px converted to rem which is 1 rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */ }
  .btn:hover::after {
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0; }

.btn:active {
  /* .btn:active is the pseudo class representing a button click */
  transform: translateY(-1px);
  /* This is -1px up from the original position of the button NOT from the hover. Since Y axis moves top to bottom a positive # moves it down and a negative # moves it up. We want button to move up when clicked so that's why we have negative # entered here. */
  box-shadow: 0 5rem 10rem rgba(0, 0, 0, 0.2);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */ }

.btn--white {
  background-color: #fff;
  color: #777; }
  .btn--white::after {
    background-color: #fff; }

.btn::after {
  /* Should match most of the properties from .btn:link and .btn:visited above as we want this to hide behind button and only be visible after we hover */
  content: "";
  /* This is for putting content like text after something. In our case we don't want to put any text we just want this blank */
  display: inline-block;
  /* Need to keep same as .btn:link and .btn:visted above */
  height: 100%;
  /* Want it to be 100% of the height of .btn:link and .btn:visted above so it hides behind */
  width: 100%;
  /* Want it to be 100% of the height of .btn:link and .btn:visted above so it hides behind */
  border-radius: 10rem;
  /* Need to keep same as .btn:link and .btn:visted above */
  position: absolute;
  /* Because .btn:link and .btn:visted above is positioned relative we can position this absolute */
  top: 0;
  left: 0;
  z-index: -1;
  /* Use -1 to hide behind */
  transition: all .4s;
  /* All animations with .btn::after will perform in .4s */ }

.btn--animated {
  animation: moveInBottom .5s ease-out .75s;
  /* .5s is duration ease-out is style of animation and .75s is the delay */
  animation-fill-mode: backwards;
  /* This sets the animation to the first values in the keyframe and retain these values through the delay process (in this case .75s); moveInBottom @keyframe at 0% has an opacity of 0% so it is invisible. If we remove this line of code from our CSS the button is visible before the animation but including this line of code makes our button invisible = @keyframe rate of moveInBottom of 0% */ }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  /* Our green color */
  display: inline-block;
  /* Making inline block so we can use box model properties on it such as margin, padding, etc. */
  text-decoration: none;
  border-bottom: 0.1rem solid #55c57a;
  padding: .3rem; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px converted to rem which is 1 rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
  transform: translateY(-0.2rem); }

.btn-text:active {
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px converted to rem which is 1 rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
  transform: translateY(0); }

.composition {
  position: relative; }
  .composition__photo {
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    /* 0 is for shadow on x-axis left to right and 2nd value which is 15px converted to 1.5rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px or rem the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
    border-radius: .2rem;
    position: absolute;
    z-index: 10;
    transition: all .2s;
    /* Not sure this is really needed */
    outline-offset: 2rem;
    /* This allows spacing between outline which acts like a border and the image; It goes with line of code below &:hover --> outline: 1.5rem solid $color-primary; */ }
    .composition__photo--p1 {
      /* Organization of pics - right top most photo */
      left: 0;
      top: -2rem; }
    .composition__photo--p2 {
      /* Organization of pics - right nost phoo */
      right: 0;
      top: 2rem; }
    .composition__photo--p3 {
      /* Organization of pics - left most photo centered */
      left: 20%;
      top: 10rem; }
    .composition__photo:hover {
      outline: 1.5rem solid #55c57a;
      /* Acts just like a border but border property doesn't allow you to easily put space in between border and image like outline does; To get space between image and outline go to &__photo above and insert outline-offset with the measurement */
      transform: scale(1.05) translateY(-0.5rem);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      /* 0 is for shadow on x-axis left to right and 2nd value which is 15px converted to 1.5rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px or rem the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
      z-index: 20; }
  .composition:hover .composition__photo:not(:hover) {
    /* This is making the pictures not hovered over a bit smaller; This is the selector composition:hover composition__photo:not(:hover) */
    transform: scale(0.95); }

.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: .3rem;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition: transform .3s; }
  .feature-box__icon {
    font-size: 6rem;
    margin-bottom: .5rem;
    display: inline-block;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    /* color goes from right to left and goes light (far left) to dark (far right) */
    -webkit-background-clip: text;
    /* Background gets clipped exactly where text is but background is hidden due to text color that's why we need next line of code below which makes the text transparent and you see through to the background iamge of the linear gradient */
    color: transparent;
    /* Allows us to see the background image */ }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

.card {
  perspective: 150rem;
  -moz-perspective: 150rem;
  position: relative;
  height: 50rem; }
  .card__side {
    color: #fff;
    font-size: 2rem;
    height: 50rem;
    transition: all .8s ease;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    backface-visibility: hidden;
    border-radius: .3rem;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15); }
    .card__side--front {
      background-color: #fff; }
    .card__side--back {
      background-color: green;
      transform: rotateY(180deg); }
      .card__side--back-1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
  .card:hover .card__side--front {
    transform: rotateY(180deg); }
  .card:hover .card__side--back {
    transform: rotateY(0); }

.row {
  max-width: 114rem;
  margin: 0 auto;
  /* Method to center block elements inside another block element */
  /* This mixin is used when using floats because when using floats it gives a height of 0 and no further styling can be done such as background-color etc. This mixin fixes this to give it height again. */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - 2 * 6rem) / 3); }
  .row .col-2-of-3 {
    width: calc(2 * ((100% - 2 * 6rem) / 3) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - 3 * 6rem) / 4); }
  .row .col-2-of-4 {
    width: calc(2 * ((100% - 3 * 6rem)  / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc(3 * ((100% - 3 * 6rem) / 4) + 2 * 6rem); }

.header {
  height: 95vh;
  /* 95% of the view height on the screen */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  /* Background image will cover size of box */
  background-position: top;
  /* Will always keep background image top in screen view; This will never get cropped out; Bottom/right/left could get cropped out based on resizing of screen */
  position: relative;
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* This is the shape in the header section; Each two numbers in parenthesis before each comma represent the x and y coordinate; The measurements start from top left corner to top right corner to bottom right corner to then bottom left corner; 100% is the x coordinate that goes horizontally so the top right corner needs the x to go 100% over to the right side and the y coordinate which is the vertical axis would be 0 since we want it to stay at the top */
  /* clip-path: polygon(50% 0, 100% 100%, 0 100%) /* Example triangle clip-path; Starting at top you only need one point so you need the 50% because you need it to move over 50% on horizontal x-axis and 0 for y-axis because you need it to stay at top. Then the right corner goes next at 100% since you need it all the way to right and 100% for vertical y-axis as you need it to go to the bottom. The left corner x-axis stays at 0 because you don't want that to move but the y-vertical axis should go down 100% */ }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem; }
  .header___logo {
    height: 3.5rem; }
  .header__text-box {
    position: absolute;
    /* Will position according to its nearest parent that is positioned relative */
    top: 40%;
    /* Brings text-box down 40% */
    left: 50%;
    /* Brings text-box left 50% */
    transform: translate(-50%, -50%);
    /* Problem with top 50% and left 50% above is it puts everything at the start of the screen at those measurements WITHOUT taking into account the length of the text-box and the height of the text-box. Transform: translate is the property to use to fix this and takes 2 arguments the first being the width and the second being the height. */
    text-align: center;
    /* This is used to center the .btn class Discover Our Tours which is displayed as an inline-block within this div container with a class of .text-box */ }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  margin-top: -20vh; }

.section-features {
  padding: 20rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/nat-4.jpg);
  background-size: cover;
  transform: skewY(-7deg);
  margin-top: -10rem; }
  .section-features > * {
    transform: skewY(7deg); }

.section-tours {
  background-color: #f7f7f7;
  padding: 25rem 0 50rem 0;
  margin-top: -10rem; }
