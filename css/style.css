@keyframes moveInLeft {
  0% {
    opacity: 0;
    /* Beginning of animation we want the property to be invisible */
    transform: translateX(-10rem);
    /* x axis goes from left to right so a positive number makes it go further right but we want this to come in from left and go right so we put it as a negative number because we want it to start out 100px to the left from its normal starting position */ }
  80% {
    transform: translateX(1rem);
    /* At 80% of animation we want the text to go further right than its normal position by 10px */ }
  100% {
    opacity: 1;
    /* End of animation we want the property to be invisible */
    transform: translate(0);
    /* 0 will end animation at its final ending spot which is equivalent to where it would show on page if there was no animation on page. */ } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    /* Beginning of animation we want the property to be invisible */
    transform: translateX(10rem);
    /* x axis goes from left to right so a positive number makes it go further right from its normal starting position */ }
  80% {
    transform: translateX(-1rem);
    /* At 80% of animation we want the text to go further left than its normal position by 10px */ }
  100% {
    opacity: 1;
    /* End of animation we want the property to be invisible */
    transform: translate(0);
    /* 0 will end animation at its final ending spot which is equivalent to where it would show on page if there was no animation on page. */ } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    /* Beginning of animation we want the property to be invisible */
    transform: translateY(3rem);
    /* y axis goes from top to bottom so a positive number makes it go further down from its normal position. So because we put this further down from its normal position when the animation gets beyond the 0% state and at 100% we have it at transform:translate(0) which is its normal position which is higher so as a result the button will move up because it starts lower than its normal position and moves up to finish at its normal position. */ }
  100% {
    opacity: 1;
    /* End of animation we want the property to be invisible */
    transform: translate(0);
    /* 0 will end animation at its final ending spot which is equivalent to where it would show on page if there was no animation on page. */ } }

*,
*::after,
*::before {
  /*    * - Is the universal selector that selects everything  */
  margin: 0;
  /* Eliminates browser default margins as we want to start clean */
  padding: 0;
  /* Eliminates browser default padding as we want to start clean */
  box-sizing: inherit;
  /* This forces all elements on page to inherit properties from their parent when it comes to box-sizing. */ }

html {
  font-size: 62.5%;
  /* All rem's based off this % here which is based originally off of 10px; Wanted to use everything by 10px. All the rem's originally used to style page used 10px but to make page more responsive and easier to modify we take the rem size we used to model our page after and then we divide that by the normal user font size which is 16px (10 /16 = .625 or 62.5%). Now this will take user font-size and scale it down to 62.5% and then adjust all our font-sizes accordingly throughout the page. */ }

body {
  box-sizing: border-box;
  /* Eliminates margins and padding in width and height of box. When you specify an elements width or height that measurement will include the margin and padding. The border box property adjusts the box accordingly to make the box the total measurements specified. Other properties if set width to 100% for example the border and padding would cause element to protrude further out from it box or container. */ }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  font-size: 1.6rem;
  line-height: 1.7;
  color: #777;
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  /* This fixes any unknown shakiness in animation */
  margin-bottom: 6rem; }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    font-weight: 700;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    /* Can specify each animation property separately or do it on one line like in .heading-primary-sub below */
    animation-duration: 1s;
    animation-timing-function: ease-out;
    padding-left: 3.5rem; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 400;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out;
    /* All animation properties specified in one line instead of listing out each one separately on to its own line like .heading-primary-main above. These properties could be listed out in any order. Order does not matter here. */
    padding-left: 1.75rem; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  display: inline-block;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  -webkit-background-clip: text;
  color: transparent;
  letter-spacing: .2rem;
  transition: all .2s; }
  .heading-secondary:hover {
    transform: skew(15deg, 2deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center !important; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem !important; }

.u-margin-bottom-medium {
  margin-bottom: 4rem !important; }

.u-margin-bottom-big {
  margin-bottom: 8rem !important; }

.u-margin-top-big {
  margin-top: 8rem !important; }

.u-margin-top-huge {
  margin-top: 10rem !important; }

.btn, .btn:link, .btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  /* When two values entered the first one is padding for top and bottom and 2nd is for padding left/right */
  display: inline-block;
  /* Need to go to parent div container with class .text-box and place text-align : center to center this */
  border-radius: 10rem;
  transition: all .2s;
  /* must be on initial state which is the .btn:link and the .btn:visited */
  position: relative;
  /* Added this relative positioning so that the .btn::after could be positioned absolute. */
  font-size: 1.6rem;
  /* Change for the <button> tag that we are using in our booking form near botton of page and not the <a> tags that we style like buttons */
  border: none;
  cursor: pointer; }

.btn:hover {
  transform: translateY(-3px);
  /* Y axis goes from top to bottom so a positive number would move it down. We want to move the button up upon hover so you input a negative #. This will move it based upon its original position */
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px converted to rem which is 1 rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */ }
  .btn:hover::after {
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0; }

.btn:active, .btn:focus {
  /* .btn:active is the pseudo class representing a button click */
  outline: none;
  /* Removes blue outline when button is in focus or when button is active; Doesn't seem to affect my page much even if this is removed */
  transform: translateY(-1px);
  /* This is -1px up from the original position of the button NOT from the hover. Since Y axis moves top to bottom a positive # moves it down and a negative # moves it up. We want button to move up when clicked so that's why we have negative # entered here. */
  box-shadow: 0 5rem 10rem rgba(0, 0, 0, 0.2);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */ }

.btn--white {
  background-color: #fff;
  color: #777; }
  .btn--white::after {
    background-color: #fff; }

.btn--green {
  background-color: #55c57a;
  color: #fff; }
  .btn--green::after {
    background-color: #55c57a; }

.btn::after {
  /* Should match most of the properties from .btn:link and .btn:visited above as we want this to hide behind button and only be visible after we hover */
  content: "";
  /* This is for putting content like text after something. In our case we don't want to put any text we just want this blank */
  display: inline-block;
  /* Need to keep same as .btn:link and .btn:visted above */
  height: 100%;
  /* Want it to be 100% of the height of .btn:link and .btn:visted above so it hides behind */
  width: 100%;
  /* Want it to be 100% of the height of .btn:link and .btn:visted above so it hides behind */
  border-radius: 10rem;
  /* Need to keep same as .btn:link and .btn:visted above */
  position: absolute;
  /* Because .btn:link and .btn:visted above is positioned relative we can position this absolute */
  top: 0;
  left: 0;
  z-index: -1;
  /* Use -1 to hide behind */
  transition: all .4s;
  /* All animations with .btn::after will perform in .4s */ }

.btn--animated {
  animation: moveInBottom .5s ease-out .75s;
  /* .5s is duration ease-out is style of animation and .75s is the delay */
  animation-fill-mode: backwards;
  /* This sets the animation to the first values in the keyframe and retain these values through the delay process (in this case .75s); moveInBottom @keyframe at 0% has an opacity of 0% so it is invisible. If we remove this line of code from our CSS the button is visible before the animation but including this line of code makes our button invisible = @keyframe rate of moveInBottom of 0% */ }

.btn-text:link, .btn-text:visited {
  font-size: 1.8rem;
  /* CHANGED BUTTON TEXT TO APPEAR A BIT BIGGER. THEY SEEMED A BIT TOO SMALL */
  color: #55c57a;
  /* Our green color */
  display: inline-block;
  /* Making inline block so we can use box model properties on it such as margin, padding, etc. */
  text-decoration: none;
  border-bottom: 0.1rem solid #55c57a;
  padding: .3rem; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px converted to rem which is 1 rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
  transform: translateY(-0.2rem); }

.btn-text:active {
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
  /* 0 is for shadow on x-axis left to right and 2nd value which is 10px converted to rem which is 1 rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
  transform: translateY(0); }

.composition {
  position: relative; }
  .composition__photo {
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    /* 0 is for shadow on x-axis left to right and 2nd value which is 15px converted to 1.5rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px or rem the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
    border-radius: .2rem;
    position: absolute;
    z-index: 10;
    transition: all .2s;
    /* Not sure this is really needed */
    outline-offset: 2rem;
    /* This allows spacing between outline which acts like a border and the image; It goes with line of code below &:hover --> outline: 1.5rem solid $color-primary; */ }
    .composition__photo--p1 {
      /* Organization of pics - right top most photo */
      left: 0;
      top: -2rem; }
    .composition__photo--p2 {
      /* Organization of pics - right most photo */
      right: 0;
      top: 2rem; }
    .composition__photo--p3 {
      /* Organization of pics - left most photo centered */
      left: 20%;
      top: 10rem; }
    .composition__photo:hover {
      outline: 1.5rem solid #55c57a;
      /* Acts just like a border but border property doesn't allow you to easily put space in between border and image like outline does; To get space between image and outline go to &__photo above and insert outline-offset with the measurement */
      transform: scale(1.05) translateY(-0.5rem);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      /* 0 is for shadow on x-axis left to right and 2nd value which is 15px converted to 1.5rem is the y-axis and is the vertical shadow. The 3rd value is the blurriness. The higher the px or rem the more blurry it is. RGBA is color and last value in rgba is the opacity or how visible an item is. The cloer to 1 the more visible it is and the closer to 0 the less visible it is */
      z-index: 20; }
  .composition:hover .composition__photo:not(:hover) {
    /* This is making the pictures not hovered over a bit smaller; This is the selector composition:hover composition__photo:not(:hover) */
    transform: scale(0.95); }

.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: .3rem;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15);
  transition: transform .3s; }
  .feature-box__icon {
    font-size: 6rem;
    margin-bottom: .5rem;
    display: inline-block;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    /* color goes from right to left and goes light (far left) to dark (far right) */
    -webkit-background-clip: text;
    /* Background gets clipped exactly where text is but background is hidden due to text color that's why we need next line of code below which makes the text transparent and you see through to the background iamge of the linear gradient */
    color: transparent;
    /* Allows us to see the background image */ }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

.story {
  width: 75%;
  margin: 0 auto;
  box-shadow: 0 3rem 6rem rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.6);
  /* This .6 sets the opacity value and by making it .6 it allows us to see through to the background video */
  border-radius: .3rem;
  padding: 6rem;
  padding-left: 9rem;
  font-size: 1.6rem;
  transform: skewX(-12deg); }
  .story__shape {
    width: 15rem;
    height: 15rem;
    float: left;
    -webkit-shape-outside: circle(50% at 50% 50%);
    shape-outside: circle(50% at 50% 50%);
    /* This property defines a shape for which adjacent inline content like text should wrap or flow around the circle. In order for this property to work it MUST be floated and have heigth and width properties. This means 50% of the rem which is 15 * 50% which is 7.5rem and then 50% of the x-axis and then 50% of the y-axis */
    -webkit-clip-path: circle(50% at 50% 50%);
    clip-path: circle(50% at 50% 50%);
    /* This actually creates the circle; The first 50% adjusts the circle size. The bigger the % the bigger the circle */
    transform: translateX(-3rem) skewX(12deg);
    /* Best way to create some padding with a floated shape is to transform and translate as opposed to using padding or margin properties. Have to have the offset skew for all the properties inside the shape here as well as in line of code below &__text */
    position: relative;
    /* Need to position here so we can get the image caption to be centered */ }
  .story__img {
    height: 100%;
    transform: translateX(-4rem) scale(1.4);
    /* Moves picture and makes it more centered. The gal in the boat was too far off to right */
    backface-visibility: hidden;
    /* Not sure this is needed here. Didn't see to do anything */
    transition: all .5s; }
  .story__text {
    transform: skewX(12deg);
    /* This is the offset to the slanted shape skew so that text etc. isn't slanted as well and that they remain completely horizontal. This also needs to be added in &__shape transform property above. */ }
  .story__caption {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 20%);
    /* This offsets text to help center text based on how long text is. The first number is the x axis and the second is the y axis. The y axis would normally be -50% but we are putting it at 20% because we want to move this down the picture because when we hover over it needs to start lower and come up. */
    color: #fff;
    text-transform: uppercase;
    font-size: 1.7rem;
    text-align: center;
    opacity: 0;
    /* Need to make this invisible until we hover over it */
    transition: all .5s;
    backface-visibility: hidden;
    /* Helps eliminate shaking with caption when it comes up */ }
  .story:hover .story__caption {
    opacity: 1;
    transform: translate(-50%, -50%);
    /* This is position we want after hover. The above transform would have had an intitial -50% if we didn't have it move downwards 20% */ }
  .story:hover .story__img {
    transform: translateX(-4rem) scale(1);
    /* Moves picture and makes it more centered. The gal in the boat was too far off to right */
    filter: blur(0.3rem) brightness(80%);
    /* blurs picture when hovering and then adjusts brightness. Values below 100% makes it darker and above 100% makes it lighter. */ }

.card {
  perspective: 150rem;
  -moz-perspective: 150rem;
  position: relative;
  height: 52rem; }
  .card__side {
    height: 52rem;
    transition: all .8s ease;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    backface-visibility: hidden;
    border-radius: .3rem;
    overflow: hidden;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15); }
    .card__side--front {
      background-color: #fff; }
    .card__side--back {
      background-color: green;
      transform: rotateY(180deg); }
      .card__side--back-1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
      .card__side--back-2 {
        background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
      .card__side--back-3 {
        background-image: linear-gradient(to right bottom, #2998ff, #5643fa); }
  .card:hover .card__side--front {
    transform: rotateY(-180deg); }
  .card:hover .card__side--back {
    transform: rotateY(0); }
  .card__picture {
    background-size: cover;
    height: 23rem;
    background-blend-mode: screen;
    -webkit-clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    border-top-left-radius: .3rem; }
    .card__picture--1 {
      background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url(../../img/nat-5.jpg); }
    .card__picture--2 {
      background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url(../../img/nat-6.jpg); }
    .card__picture--3 {
      background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url(../../img/nat-7.jpg); }
  .card__heading {
    font-size: 2.8rem;
    font-weight: 300;
    text-transform: uppercase;
    text-align: right;
    color: #fff;
    position: absolute;
    top: 12rem;
    right: 2rem;
    width: 75%; }
  .card__heading-span {
    padding: 1rem 1.5rem;
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone; }
    .card__heading-span--1 {
      background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85)); }
    .card__heading-span--2 {
      background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85)); }
    .card__heading-span--3 {
      background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85)); }
  .card__details {
    padding: 3rem; }
    .card__details ul {
      list-style: none;
      width: 80%;
      margin: 0 auto; }
      .card__details ul li {
        text-align: center;
        font-size: 1.5rem;
        padding: 1rem; }
        .card__details ul li:not(:last-child) {
          border-bottom: 1px solid #eee; }
  .card__cta {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    text-align: center; }
  .card__price-box {
    text-align: center;
    color: #fff;
    margin-bottom: 8rem; }
  .card__price-only {
    font-size: 1.4rem;
    text-transform: uppercase; }
  .card__price-value {
    font-size: 6rem;
    font-weight: 100; }

.bg-video {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  z-index: -1;
  /* This is so video is behind everything else */
  opacity: .15;
  overflow: hidden;
  /* This will make any part of video that overflows the container hidden. */ }
  .bg-video__content {
    height: 100%;
    width: 100%;
    object-fit: cover;
    /* This allows the video to fill parent element or cover entire parent element while maintaining aspect ratio. If it goes over it will be clipped off */ }

.form__group:not(:last-child) {
  margin-bottom: 2rem; }

.form__input {
  font-size: 1.5rem;
  font-family: inherit;
  color: inherit;
  padding: 1.5rem 2rem;
  /* top bottom is first input and sides are the 2nd input. */
  border-radius: 2px;
  background-color: rgba(255, 255, 255, 0.5);
  border: none;
  border-bottom: .3rem solid transparent;
  /* Fixes the issue where the bottom input of email address kept moving down a little bit but was noticeable when Full Name got put in focus. The reason this was happening was because when Full Name got put in focus it created the green border and pushed the Email Address input field down. By creating a border for it already in its current state before focus but making the border transparent so you don't see it fixes the issue because its already there. Now when it becomes in focus it just turns from transparent to green */
  width: 90%;
  display: block;
  /* Forces each input to have its own line with label at bottom; Before inserting this the label was on the side */
  transition: all .3s; }
  .form__input:focus {
    /* This eliminates the standard blue box on input when it is in focus but creates a custom focus with a green underline and box shadow instead */
    outline: none;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.1);
    border-bottom: 0.3rem solid #55c57a; }
    .form__input:focus:invalid {
      /* This will keep a solid reddish dark bottom border while input is invalid or blank when it is in focus. Once input is valid it will switch to green border while in focus to let you know that the input is good */
      border-bottom: 0.3rem solid #ff7730; }
  .form__input::-webkit-input-placeholder {
    color: #999;
    /* This is the color of the placeholder text before you type something in the input */ }

.form__label {
  font-size: 1.2rem;
  font-weight: 700;
  margin-left: 2rem;
  margin-top: .7rem;
  display: block;
  transition: all .3s;
  /* Used as transition for any animmations on form__label below */ }

.form__input:placeholder-shown + .form__label {
  /* + is the immediate adjacent sibling selector for the label. This is the labels status before anything is typed in input fields which is that label is hidden and not shown; This causes label that normally sits below input field to be hidden. You need both visibility: hidden and opacity at 0 because you can't animate visibility:hidden but you can animate the opacity */
  opacity: 0;
  /* This is the labels status before anything is typed in input fields which is that label is hidden and not shown; This causes label that normally sits below input field to be hidden. You need both visibility: hidden and opacity at 0 because you can't animate visibility:hidden but you can animate the opacity */
  visibility: hidden;
  /* This is the labels status before anything is typed in input fields which is that label is hidden and not shown; This causes label that normally sits below input field to be hidden. You need both visibility: hidden and opacity at 0 because you can't animate visibility:hidden but you can animate the opacity */
  transform: translateY(-4rem);
  /* This causes labels starting position to be in input field but hidden. So when something is typed you will see the animation of the label going to its normal position which is below the input field and the animation is .3s in duration as indentified in block of code above in &__label - transition: all .3s */ }

.form__radio-group {
  width: 49%;
  display: inline-block; }

.form__radio-input {
  display: none; }

.form__radio-label {
  font-size: 1.6rem;
  cursor: pointer;
  position: relative;
  /* This is made position:relative so we can absolutely position the &__radio-button */
  padding-left: 4.5rem;
  /* Give label some space from the radio button */ }

.form__radio-button {
  /* This is the custom radio button we created through the <span> tag */
  height: 3rem;
  width: 3rem;
  border: 0.5rem solid #55c57a;
  border-radius: 50%;
  /* Border radius of 50% makes a circle */
  display: inline-block;
  /* Need inline-block to keep the radio buttons on same line and for height and width properties to work as height and width only work with inline-block or block elements */
  position: absolute;
  /* position absolute from parent &__radio-label */
  left: 0;
  top: -.4rem; }
  .form__radio-button::after {
    /* This is the inner circle created when we select one of the radio buttons; In other words this is the selection of one of the radio buttons */
    content: "";
    display: block;
    height: 1.3rem;
    width: 1.3rem;
    border-radius: 50%;
    /* Border radius of 50% makes a circle */
    position: absolute;
    /* You can absolute position an item to its parent even though its parent which is &__radio-button is not relative positioned but can do it as long as the parent is positioned either relative or absolute. Parent in this case is positioned absolute instead of relative because the parent is needed to be positioned absolute to its own parent */
    top: 50%;
    /* Centering from top */
    left: 50%;
    /* Centering from left */
    transform: translate(-50%, -50%);
    /* Offset needed to account for sizing of content to completely center element */
    background-color: #55c57a;
    opacity: 0;
    transition: opacity .2s;
    /* This is the animation duration for the opacity of the radio button once it is checked. This transition property is related to the &__radio-input:checked ~ &__radio-label &__radio-button::after opacity: 1 below. This line of code could also be inserted there and work as well */ }

.form__radio-input:checked ~ .form__radio-label .form__radio-button::after {
  /* This is selecting the &__radio-input and ~ means any sibling of &__radio-input which is $__radio-label and then the &__radio-button with the after selector */
  opacity: 1;
  /* transition: opacity .2s could work here as well instead of up above in &::after */ }

.row {
  max-width: 114rem;
  margin: 0 auto;
  /* Method to center block elements inside another block element */
  /* This mixin is used when using floats because when using floats it gives a height of 0 and no further styling can be done such as background-color etc. This mixin fixes this to give it height again. */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - 2 * 6rem) / 3); }
  .row .col-2-of-3 {
    width: calc(2 * ((100% - 2 * 6rem) / 3) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - 3 * 6rem) / 4); }
  .row .col-2-of-4 {
    width: calc(2 * ((100% - 3 * 6rem)  / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc(3 * ((100% - 3 * 6rem) / 4) + 2 * 6rem); }

.header {
  height: 95vh;
  /* 95% of the view height on the screen */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  /* Background image will cover size of box */
  background-position: top;
  /* Will always keep background image top in screen view; This will never get cropped out; Bottom/right/left could get cropped out based on resizing of screen */
  position: relative;
  -webkit-clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* This is the shape in the header section; Each two numbers in parenthesis before each comma represent the x and y coordinate; The measurements start from top left corner to top right corner to bottom right corner to then bottom left corner; 100% is the x coordinate that goes horizontally so the top right corner needs the x to go 100% over to the right side and the y coordinate which is the vertical axis would be 0 since we want it to stay at the top */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* This is the shape in the header section; Each two numbers in parenthesis before each comma represent the x and y coordinate; The measurements start from top left corner to top right corner to bottom right corner to then bottom left corner; 100% is the x coordinate that goes horizontally so the top right corner needs the x to go 100% over to the right side and the y coordinate which is the vertical axis would be 0 since we want it to stay at the top */
  /* clip-path: polygon(50% 0, 100% 100%, 0 100%) /* Example triangle clip-path; Starting at top you only need one point so you need the 50% because you need it to move over 50% on horizontal x-axis and 0 for y-axis because you need it to stay at top. Then the right corner goes next at 100% since you need it all the way to right and 100% for vertical y-axis as you need it to go to the bottom. The left corner x-axis stays at 0 because you don't want that to move but the y-vertical axis should go down 100% */ }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem; }
  .header___logo {
    height: 3.5rem; }
  .header__text-box {
    position: absolute;
    /* Will position according to its nearest parent that is positioned relative */
    top: 40%;
    /* Brings text-box down 40% */
    left: 50%;
    /* Brings text-box left 50% */
    transform: translate(-50%, -50%);
    /* Problem with top 50% and left 50% above is it puts everything at the start of the screen at those measurements WITHOUT taking into account the length of the text-box and the height of the text-box. Transform: translate is the property to use to fix this and takes 2 arguments the first being the width and the second being the height. */
    text-align: center;
    /* This is used to center the .btn class Discover Our Tours which is displayed as an inline-block within this div container with a class of .text-box */ }

.footer {
  background-color: #333;
  padding: 10rem 0;
  font-size: 1.4rem;
  color: #f7f7f7; }
  .footer__logo-box {
    text-align: center;
    /* Center inline property within a block element or div container by using text-align center as <img> tag is inline and thus is treated like text for centering purposes */
    margin-bottom: 8rem; }
  .footer__logo {
    width: 15rem;
    height: auto; }
  .footer__navigation {
    border-top: 1px solid #777;
    padding-top: 2rem;
    display: inline-block;
    /* border-top above was extending past the li items and we want line to only be above li item and not extend out beyond li items; To fix this we make the element inline-block because the div will only be as wide as its content and thus the border will not overun the text */ }
  .footer__list {
    list-style: none; }
  .footer__item {
    display: inline-block; }
    .footer__item:not(:last-child) {
      margin-right: 1.5rem; }
  .footer__link:link, .footer__link:visited {
    color: #f7f7f7;
    background-color: #333;
    text-decoration: none;
    text-transform: uppercase;
    display: inline-block;
    transition: all .2s; }
  .footer__link:hover, .footer__link:active {
    color: #55c57a;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4);
    transform: rotate(5deg) scale(1.3); }
  .footer__copyright {
    border-top: 1px solid #777;
    padding-top: 2rem;
    width: 80%;
    float: right; }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  margin-top: -20vh; }

.section-features {
  padding: 20rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/nat-4.jpg);
  background-size: cover;
  transform: skewY(-7deg);
  margin-top: -10rem; }
  .section-features > * {
    transform: skewY(7deg); }

.section-tours {
  background-color: #f7f7f7;
  padding: 25rem 0 15rem 0;
  margin-top: -10rem; }

.section-stories {
  position: relative;
  /* Positioned relative so video .bg-video__content can be positioned absolute */
  padding: 15rem 0; }

.section-book {
  padding: 15rem 0;
  background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }

.book {
  /* This is the booking window to book an appointment */
  background-image: linear-gradient(105deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.9) 50%, transparent 50%), url(../../img/nat-10.jpg);
  /* Linear-gradient with background image */
  background-size: 100%;
  /* 100% is the same thing as cover */
  border-radius: .3rem;
  /* rounds corner of image */
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.2);
  height: 50rem; }
  .book__form {
    width: 50%;
    padding: 6rem; }
